# NxM 보드 완주하기

## 📅 Problem Log

**Started**: 2026.02.08

**Solved:** 2026.02.08

---

## 🗝️ Problem Info

- **문제 링크**: **[9944](https://www.acmicpc.net/problem/9944)**
    
- **난이도**: <img src="https://static.solved.ac/tier_small/13.svg" height="16px" style="vertical-align:middle;"> Gold 3
    
- **태그**: #구현 #브루트포스_알고리즘 #백트래킹
    

---

## 📓 Problem Description

- **문제 요약**: 장애물, 보드의 경계, 이미 지나온 칸을 만나기 전까지 계속 이동하는 공이 모든 칸을 방문하기 위한 이동 횟수의 최솟값 구하기
    
- **입력**:
```
n, m(보드의 크기)
arr[n][m](보드)
```
- **출력**:
```
case tc: ans (최소 이동 횟수)
```
- **제약 조건**:
    

---

## 💡 Approach

### 핵심 아이디어

### 접근 전략 브레인스토밍

-  몇 번의 케이스가 있는거지? 일단 이건 넘겨두고 아까 푼 13901번처럼 풀면 시간초과가 나려나? 우선 보드를 입력 받은뒤 첫번째 칸 부터 하나하나 시뮬레이션 해보기.
    

---

## 🗃️ Variable

Plaintext

```
숫자) r, c, ar, ac, nr, nc, dots, ans, tc, vcnt, mcnt
문자열) in
불 배열) arr[r][c]
```

---

## ⚙️ Pseudocode

Plaintext

```
케이스 번호(tc) = 1

무한반복
	보드 크기 (r,c)입력
	
	점(빈칸) 갯수 (dots) = 0
	최소 이동 횟수 (ans) = 1e9
	
	r만큼 반복
		보드 한줄 (in) 입력
		c만큼 반복
			만약 in[j] == '.'라면
				arr[i][j] = true
				dots++
			아니라면
				arr[i][j] = false
				
	r만큼 반복
		c만큼 반복
			만약 arr[i][j] = true라면
				재귀함수 호출 (solve(i, j)) 
```

```
solve 함수 (ar, ac)
	방문한 칸 갯수 (vcnt) = 1
	공 굴린 횟수 (mcnt) = 0
	
	만약 vcnt == dots && mcnt < ans라면
		ans = mcnt
		
	4번 반복
		다음에 도달할 위치 (nr, na) = ar, ac
```
---

## 💻 Code

- **[cpp](1000.cpp)**


---

## ☑️ Submission Record

- **제출 언어**:
    
- **메모리**:
	
- **시간**:
	
- **코드 길이**:
	
---

## 📝 Memo

2/8 백트레킹 개념이 아직 어렵다. 백트래킹 공부 후 다시 풀자..!

> Written by **OjOj717**